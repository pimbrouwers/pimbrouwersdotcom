<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta content="width=device-width,initial-scale=1" name="viewport">
  <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
  <title>Reading CSV's and other delimited files with F# | Pim Brouwers</title> 
  <link href="/style.css" rel="stylesheet" type="text/css">
</head>

<body>
  <header>    
    <p><a href="/">&laquo; Go back</a></p>
    <h1>Reading CSV's and other delimited files with F#</h1>    
    <p class="big">When most people are introduced to F# they're shown one or more of the available <a href="https://docs.microsoft.com/en-us/dotnet/fsharp/tutorials/type-providers/" target="_blank">type providers</a>. These type providers will automatically generate types for your data based on sampling, which is provided inline, from a <code>StreamReader</code> or via URL.</p>    
  </header>

  <hr/>

  <small class="muted monospace">FEBRUARY 1, 2019</small>

  <p>If you're exploring a new data source, like an API, these are wickedly sexy and effective tools. However, in production they can become a bit of pain to use and manage.</p>

  <p>F# is absolutely loaded with what I'll call "language tools", and providers are an excellent example of this. Which makes it easy to forget that you will at times need to go lower and in most situations I'd suggest you'll either want to be there or inevitably wind up there.</p>

  <p>If you're working in .NET and not using <a href="https://joshclose.github.io/CsvHelper/" target="_blank">CsvHelper</a> to read/write delimited files, you're missing out. It's an incredible tool. </p>

  <blockquote>For those "rolling their own", just stop, right now...</blockquote>

  <p>As always, using imperative libraries in F# typically means writing small adapter functions. Below is a snippet from a module I frequently use to parse delimited files in my F# projects, including a sample of how to partially apply the base <code>read</code> function. <code>read</code> is configurable at runtime and accepts a file path & record mapper function.</p>
  <code><pre>module Csv =    
  open CsvHelper 
  open System.IO

  let read config path mapCsv =
      seq {
          use reader = new StreamReader(path = path)
          use csv = new CsvReader(reader, configuration = config)         

          csv.Read() |> ignore
          csv.ReadHeader() |> ignore

          while csv.Read() do
              yield mapCsv csv          
      }

  let readTabDelimited path mapCsv = 
      let config = Configuration()
      config.Delimiter <- "\t"
      read config path mapCsv</pre></code>

  <p>To use simply provide a working file path and function with a <code>CsvReader -> 'a</code> signature.</p>

  <code><pre>type MyRecord = { FullName : string }

  Csv.readTabDelimited 
        "./some_tab_delimited_file.txt" 
        (fun csv -> { FullName = csv.GetField("FULL_NAME") })  </pre></code>

  <p>And that's it! You might be asking yourself why not use <code>csv.GetRecords&lt;MyRecord&gt;</code>? I personally like to avoid the <code>[&lt;CliMutable&gt;]</code> at all costs, because that's why I'm using F# in the first place. Plus, creating new record types in F# is so arbitrary that I am PERFECTLY happy to write my own mapping code, even for things like consuming <code>IDbReader</code>'s.</p>

  <p>It's important to remember that with very little massaging F# can be great at inteorping with imperative libraries.</p>

  <hr/>

  <footer>
    <div>Pim Brouwers</div>
    <div>Senior Software Architect @ <a href="nhlpa.com" target="_blank">NHLPA</a></div>
    <div>
      <a href="//twitter.com/pim_brouwers" target="_blank">Twitter</a>
      <a href="//github.com/pimbrouwers" target="_blank">GitHub</a>
    </div>
  </footer>
</body>

</html>