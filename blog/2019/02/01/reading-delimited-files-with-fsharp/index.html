<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta content="width=device-width,initial-scale=1" name="viewport">
	<meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
	<title>Reading CSV's and other delimited files with F#</title>	
	<link rel="apple-touch-icon" sizes="57x57" href="/assets/fav/apple-icon-57x57.png">
	<link rel="apple-touch-icon" sizes="60x60" href="/assets/fav/apple-icon-60x60.png">
	<link rel="apple-touch-icon" sizes="72x72" href="/assets/fav/apple-icon-72x72.png">
	<link rel="apple-touch-icon" sizes="76x76" href="/assets/fav/apple-icon-76x76.png">
	<link rel="apple-touch-icon" sizes="114x114" href="/assets/fav/apple-icon-114x114.png">
	<link rel="apple-touch-icon" sizes="120x120" href="/assets/fav/apple-icon-120x120.png">
	<link rel="apple-touch-icon" sizes="144x144" href="/assets/fav/apple-icon-144x144.png">
	<link rel="apple-touch-icon" sizes="152x152" href="/assets/fav/apple-icon-152x152.png">
	<link rel="apple-touch-icon" sizes="180x180" href="/assets/fav/apple-icon-180x180.png">
	<link rel="icon" type="image/png" sizes="192x192"  href="/assets/fav/android-icon-192x192.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/assets/fav/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="96x96" href="/assets/fav/favicon-96x96.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/assets/fav/favicon-16x16.png">
	<link rel="manifest" href="/assets/manifest.json">
	<meta name="msapplication-TileColor" content="#ffffff">
	<meta name="msapplication-TileImage" content="/ms-icon-144x144.png">
	<meta name="theme-color" content="#ffffff">
	<meta name="author" content="Pim Brouwers" />
	<meta name="keywords" content="pim brouwers programming f# sql powershell" />
	<meta content="How to read delimited files with F# and CsvHelper." name="description">	
	<meta content="Reading CSV's and other delimited files with F#" property="og:title">
	<meta content="How to read delimited files with F# and CsvHelper." property="og:description">
	<meta content="?s=300" property="og:image">
	<meta content="510673212" property="twitter:account_id">
	<meta content="summary" name="twitter:card">
	<meta content="@pim_brouwers" name="twitter:site">
	<meta content="@pim_brouwers" name="twitter:creator">
	<meta content="" name="google-site-verification">
	<link href="/assets/style.css" rel="stylesheet" type="text/css">
</head>
<body>
	<header>
		<nav>
			<div class="nav-brand">Pim Brouwers</div>
			<a class="nav-link" href="/">Home</a>
			<a class="nav-link" href="/about">About</a>
			<a class="nav-link" href="/blog" class="mr1">Blog</a>   
		</nav>
	</header>
	<main>
		<article>
			
<div class="blog-date">2019/02/01</div>
<h1 class="blog-title">Reading CSV's and other delimited files with F#</h1>

<p>When most people are introduced to F# they're shown one or more of the available <a href="https://docs.microsoft.com/en-us/dotnet/fsharp/tutorials/type-providers/" target="_blank">type providers</a>. These type providers will automatically generate types for your data based on sampling, which is provided inline, from a <code>StreamReader</code> or via URL.</p>

<p>If you're exploring a new data source, like an API, these are wickedly sexy and effective tools. However, in production they can become a bit of pain to use and manage.</p>

<p>F# is absolutely loaded with what I'll call "language tools", and providers are an excellent example of this. Which makes it easy to forget that you will at times need to go lower and in most situations I'd suggest you'll either want to be there or inevitably wind up there.</p>

<p>If you're working in .NET and not using <a href="https://joshclose.github.io/CsvHelper/" target="_blank">CsvHelper</a> to read/write delimited files, you're missing out. It's an incredible tool.	</p>

<blockquote>For those "rolling their own", just stop, right now...</blockquote>

<p>As always, using imperative libraries in F# typically means writing small adapter functions. Below is a snippet from a module I frequently use to parse delimited files in my F# projects, including a sample of how to partially apply the base <code>read</code> function. <code>read</code> is configurable at runtime and accepts a file path & record mapper function.</p>
<code><pre>module Csv =    
open CsvHelper 
open System.IO

let read config path mapCsv =
    seq {
        use reader = new StreamReader(path = path)
        use csv = new CsvReader(reader, configuration = config)         

        csv.Read() |> ignore
        csv.ReadHeader() |> ignore

        while csv.Read() do
            yield mapCsv csv          
    }

let readTabDelimited path mapCsv = 
    let config = Configuration()
    config.Delimiter <- "\t"
    read config path mapCsv</pre></code>

<p>To use simply provide a working file path and function with a <code>CsvReader -> 'a</code> signature.</p>

<code><pre>type MyRecord = { FullName : string }

Csv.readTabDelimited 
      "./some_tab_delimited_file.txt" 
      (fun csv -> { FullName = csv.GetField("FULL_NAME") })  </pre></code>

<p>And that's it! You might be asking yourself why not use <code>csv.GetRecords&lt;MyRecord&gt;</code>? I personally like to avoid the <code>[&lt;CliMutable&gt;]</code> at all costs, because that's why I'm using F# in the first place. Plus, creating new record types in F# is so arbitrary that I am PERFECTLY happy to write my own mapping code, even for things like consuming <code>IDbReader</code>'s.</p>

<p>It's important to remember that with very little massaging F# can be great at inteorping with imperative libraries.</p>
		</article>	
	</main>
</body>
</html>

